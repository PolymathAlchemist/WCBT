from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path

from backup_engine.backup.service import run_backup
from backup_engine.restore.service import run_restore


@dataclass(frozen=True)
class _FileSpec:
    relative_path: Path
    content: bytes


def _write_source_tree(root: Path, files: list[_FileSpec]) -> None:
    for spec in files:
        full_path = root / spec.relative_path
        full_path.parent.mkdir(parents=True, exist_ok=True)
        full_path.write_bytes(spec.content)


def _find_single_backup_manifest(data_root: Path) -> Path:
    """
    Locate the single backup manifest generated by an end-to-end run.

    We intentionally avoid assuming a specific internal manifest layout under data_root.
    If multiple candidates exist, we fail with a helpful message so the layout can be
    made explicit later (or the selector can be tightened).
    """
    candidates = sorted(p for p in data_root.rglob("*.json") if "manifest" in p.name.lower())

    if len(candidates) == 1:
        return candidates[0]

    tree_listing = "\n".join(str(p.relative_to(data_root)) for p in sorted(data_root.rglob("*")))
    raise AssertionError(
        "Expected exactly one '*manifest*.json' under data_root.\n"
        f"Found {len(candidates)} candidates:\n"
        + "\n".join(f"  - {p}" for p in candidates)
        + "\n\n"
        f"data_root contents:\n{tree_listing}"
    )


def _assert_tree_matches(source_root: Path, restored_root: Path, files: list[_FileSpec]) -> None:
    for spec in files:
        src_path = source_root / spec.relative_path
        dst_path = restored_root / spec.relative_path

        assert src_path.exists(), f"Missing expected source file: {src_path}"
        assert dst_path.exists(), f"Missing restored file: {dst_path}"

        assert (
            dst_path.read_bytes() == src_path.read_bytes()
        ), f"Content mismatch: {spec.relative_path}"
        assert (
            dst_path.stat().st_size == src_path.stat().st_size
        ), f"Size mismatch: {spec.relative_path}"


def test_e2e_backup_then_restore_verify_size_and_artifacts_survive(tmp_path: Path) -> None:
    source_root = tmp_path / "source"
    data_root = tmp_path / "data_root"
    restore_destination = tmp_path / "restore_destination"

    files = [
        _FileSpec(relative_path=Path("alpha.txt"), content=b"alpha\n"),
        _FileSpec(relative_path=Path("nested") / "beta.bin", content=b"\x00\x01\x02\x03"),
        _FileSpec(relative_path=Path("nested") / "deeper" / "gamma.txt", content=b"gamma\n"),
    ]

    _write_source_tree(source_root, files)

    # Backup (plan + execute) into an isolated data_root.
    run_backup(
        profile_name="e2e",
        source=source_root,
        dry_run=False,
        data_root=data_root,
        excluded_directory_names=None,
        excluded_file_names=None,
        use_default_excludes=True,
        max_items=100,
        write_plan=False,
        plan_path=None,
        overwrite_plan=False,
        clock=None,
        execute=True,
        force=True,
        break_lock=True,
    )

    manifest_path = _find_single_backup_manifest(data_root)

    # Restore into a clean destination root.
    run_restore(
        manifest_path=manifest_path,
        destination_root=restore_destination,
        mode="overwrite",
        verify="size",
        dry_run=False,
        data_root=data_root,
        clock=None,
    )

    # Validate restored files.
    _assert_tree_matches(source_root, restore_destination, files)

    # Artifacts must survive promotion and land in the final destination root.
    artifacts_root = restore_destination / ".wcbt_restore"
    assert artifacts_root.exists(), "Expected restore artifacts root to exist after promotion."
    assert (
        artifacts_root.is_dir()
    ), "Expected restore artifacts root to be a directory after promotion."
